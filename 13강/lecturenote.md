# 네트워크 계층 5

## Distance Vector Algorithm
- x -> y의 최단거리를 `recursive`로 구한다.
    - dx(y) = minv { c(x,v) + dv(y) } (v는 인접 노드)

- 예시
    - du(z)를 구하고 싶은데, u는 v, x, w와 인접해 있다.
    - 그러면 du(z) = min [ {c(u, v) + dv(z)},
                        {c(u, x) + dx(z)},
                        {c(u, w) + dw(z)}]
    - 각 노드가 [dx(y), dx(w), ... , dx(v)]라는, 즉, 자기 자신과 다른 모든 노드까지의 거리가 저장된 `distance vector`를 구한 후 자기가 알고 있는 distance vector를 `broadcast`로 넘겨주니 `distance vector algorithm`이다.
        - 보내주는 것은 distance vector를 받아, 자신의 distance vector 값이 `갱신이 되는 정보가 있으면` 그 결과를 전달. 그 후 `또 새로 받으면 계산 후 전달`.
    - 안정화 될 때까지 동작

- `분산적으로 처리`하며 정보를 조금씩 갱신시키는 방식.

### 만약 link cost가 바뀌면?
- link에 포함된 노드들은(라우터) 이와 관련하여 자기 자신의 distance vector를 다시 계산
- 그 후, 갱신되는 값이 있으면 위와 같은 과정 또 반복
- link cost가 적어지고, 이미 정해져 있던 최단 루트면 금방 계산이 끝나고 안정화된다.
- 반대로 link cost가 많아지면 루트가 바뀌게 되어 계산이 커질 수 있다. x-y링크가 바뀌었다고 치자, y->x의 값이 바뀌었는데, y->z->x를 선택하기에는, 사실 y->z->y->x였을 경우, 다른 선택지 값도 사실 갱신되어야 했어서 문제가 발생하므로, `count to infinity`의 문제가 발생할 수 있다.
    - 이는 전체 그래프 정보를 모르는 상태에서 단편적 정보에 의존하기 때문에 발생하는 문제다.
    - 고로, 위와 같은 경우, 차라리 기존에 구한 dz(x)를 `y에게는 무한대`라고 하고(직접 연관 없는 x에는 기존 정보 넘겨줘도 무방), 이 정보를 다시 구하는 것이 더 현명할 수 있다.
    - 즉, dy(x)를 구할 때 쓰는 dz(x)는 dy(x)의 정보에 `의존`한다. 그래서 기존 정보를 사용해서는 안된다.

### 참고로, 이 distance vector algorithm도 하나의 네트워크 상에서 동작하는 알고리즘. 즉, 관리 주체가 동일한 네트워크의 내부에서만 동작.
- 그러면 네트워크 외부로 나가, 여러 네트워크를 연결하는 routing algorithm은? 이걸 다음 시간에