# 컴퓨터 네트워크 기본 2

## 지난주 복습
- TCP, UDP
- 현대 인터넷은 패킷 기반. 패킷 단위로 묶여 출발지에서 도착지까지 라우터 거치며 간다.
- 패킷 기반은 여러 사람이 한번에 몰려서 큐에 쌓이면 지연과 유실이 일어난다.
- delay는 4가지로 분류 가능. processing delay, queueing delay, transmission delay, propagation delay

## caravan analogy
- 라우터상 delay를 고속도로에 비유.
- 차량 10대가 동시에 다녀야 함(10bit packet)
- 중간에 톨게이트가 있다(라우터).
- 두번째 라우터까지 걸리는 시간 묻는데, transmission delay와 propagation delay만 고려 대상인 문제.
- 중요한건 숫자가 아니다. 실제 전자 통신에서 속도는 빛의 속도다. 패킷의 앞부분은 이미 라우터를 빠져나가 다음 라우터에 들어와 있다. 하지만, `뒤의 애들이 다 와서 하나로 뭉쳐지기 전까지는 나가지 않는다.`

## 계층
- Application layer(HTTP)
- Transport layer(TCP, UDP)
- Network layer(IP)
- Link layer(IEEE 802.11(Wi-fi), LTE, Ethernet)

- 각 계층마다 유명한 프로토콜들을 볼 것이다.
- 하위 계층은 상위 계층에 사용하기 좋으라고 기능을 제공한다.

## network apps
- e-mail, web 등 다양한 프로그램들. 즉, 응용계층에 있는 것은 웹 기능이 있는 프로세스(프로그램)들이다.
- 우리가 이런 프로그램을 만들 때, 중간에 라우터니 뭐니 있는 것은 알지만 그런건 신경쓰지 않고, 프로세스와 반대편 프로세스 사이의 통신만 고려하면 된다.(중간은 신경 안써도 된다.)
    - 왜냐하면, 이러한 계층은 edge에만 존재하고, 라우터에는 network layer까지만 존재하기 때문이다.

## 서버-클라이언트 구조
- 클라이언트는 웹 브라우저, 서버는 웹 서버
- 서버
    - 서버는 24시간 동작해야 하고, `permanent한 IP 주소`를 가져야 한다. 바뀌지 않고 고정된 IP 주소를 가져야 한다.
    - permanent해야 하는 이유는 그래야 찾아올 수 있기 때문이다.
- 클라이언트
    - 클라이언트는 고정되지 않은 주소를 가지고 있어도 괜찮다.

## 프로세스들 사이의 통신
- 결국 이러한 통신은 프로세스와 프로세스 사이의 통신이다.
- OS 내부에서는 시스템콜을 통해 같은 컴퓨터 내의 다른 프로세스들 사이의 통신에 대한 인터페이스를 마련해 놓았다. 이와 마찬가지로 OS는 `다른 컴퓨터 사이의 프로세스들 간의 통신 인터페이스도 만들어 놓았다.` 이를 `소켓(socket)`이라고 한다.
- 한쪽 소켓에서 쓰면, 반대쪽에서는 이를 읽어들인다.

## Sockets
- 그런데, 이러기 위해서는 둘이 사전에 연결되어야 한다. 그러기 위해서는 통신하고자 하는 상대 소켓의 주소를 알아야 하고, 이에 대한 인덱싱이 필요하다. 그것이 바로 `IP주소와 포트번호의 컴비네이션`으로 구현된다.
- IP주소를 통해 어떤 컴퓨터인지 알아내고, 포트번호를 통해 그 컴퓨터 내 어떤 프로세스(프로그램)인지 알아낸다.
- 우리가 예를들어, 네이버에 접속하려 한다면 네이버의 관련 접속을 위한 IP주소와 포트번호(80)를 입력해야 한다.
    - 근데, 우리가 접속할 때는 www.naver.com같은 방식으로 접속한다. 이는 `DNS 덕분에 IP주소`로 변환되기 때문이다.
    - 그럼 포트번호(80)는? 따로 안치면 80이 자동으로 입력된다.
    - 웹서버를 운영하는 대부분의 기업은 포트 번호를 80으로 한다. 왜 `공통된 포트`를 쓸까? 포트번호 다르면 사람들이 접근하기 힘들기 때문에 찾아가기 쉽게 같은걸 쓴다.

## Transport 계층에서 이런걸 제공해 주면 좋겠어요. Application 계층이 하위 계층에 원하는 것.
- data integrity : 신뢰성 있는 전송
- timing : 적은 delay가 걸렸으면 좋겠어요.
- throughput : 처리량 좋으면 좋겠어요.
- 보안

- `이 중 Transport 계층이 제공하는 것은 단 한가지, data integrity(TCP는 제공, 심지어 UDP는 미제공)`.

## Timing vs Throughput
- Timing : 내가 보낸 패킷이 특정 시간 내에 도착해야 한다.
- Throughput : 1초에 n개의 패킷이 도달해야 한다.(각 패킷이 timing을 맞출 필요는 없다. 그냥 단위 시간 내에 어느 양만 처리되면 된다.)
- 정리하면, 한 패킷의 도달 시간과 단위 시간의 패킷 처리량의 차이다.

## ppt 2-15
- 유명 application과 그들이 쓰는 전송 계층.
- HTTP가 제일 유명(웹의 기반)

## HTTP
- HyperText Transfer Protocol
- hypertext : 텍스트다. 중간중간에 링크가 있어서 다른 텍스트로 갈 수 있다. http는 이런걸 보내주는 protocol이다.
- 클라이언트는 서버에 hypertext를 요청(`request`)하고, 서버는 그걸 보내준다(`response`).
- 바로 이 request, response가 HTTP의 전부다.
- 근데, 이러기 위해 연결이 되어야 하고, 그걸 `TCP`가 해준다(TCP 기반). HTTP를 사용하기 전에 `TCP connection`이 이루어져야한다.
- HTTP는 `stateless(상태가 없음)`하다. 즉, 요청이 들어오면 처리하고 그대로 잊어버린다. 상대방의 상태를 기억하지 않는다.

## HTTP connections
- TCP를 어떻게 연결하냐에 따라 두가지로 나뉜다.
- non-persistent HTTP
    - 요청, 응답 후 연결을 `끊는다`.
- persistent HTTP
    - 요청, 응답 후에도 연결을 `유지`하며 계속 사용한다.

- 예를 들어, 네이버에 메인페이지와 레퍼런스로 필요한 그림 파일 10개를 요청하는 상황이다.
- 그럼 우선, TCP connection을 만들고, 메인페이지를 요청해 응답 받는다.
    - 이 이후 끊었다가 파싱하는 과정에서 그림 필요한게 발견되면 다시 연결하고 그림 요청하고 다시 끊고하면 non-persistent. 연결된 상태 유지하면서 재연결 없이 그림 파일 필요하다 보이면 요청하고 하면 persistent.

- 현재는 `persistent HTTP`를 사용한다.
- 참고로 실제로 persistent HTTP할 때, 일단 파싱한 후, 추가적으로 필요한 데이터(사진 10장)가 무엇인지 파악하고 한번에 요청한다(`파이프라인`을 혼합한 것).

## 질문 내용 중
- TCP connection을 끊는 것은 한쪽이 아니라 양쪽에서 끊어준다. ppt랑 다르다.